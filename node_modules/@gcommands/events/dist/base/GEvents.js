"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.GEvents=void 0;var _discord=require("discord.js");var _Color=require("../structures/Color");var fs=_interopRequireWildcard(require("fs"));var _Event=require("../structures/Event");var _util=require("../util/util");var path=_interopRequireWildcard(require("path"));var _Constants=require("../util/Constants");function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=="function")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=="default"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}class GEvents{constructor(client,options){if(typeof client!=="object"){console.log(new _Color.Color("&d[GEvents] &cNo discord.js client provided!",{json:false}).getText());return}this.client=client;this.eventDir=this.client.eventDir?this.client.eventDir:options===null||options===void 0?void 0:options.eventDir;this.client.gevents=new _discord.Collection;if(!this.eventDir)return;this.__loadEventFiles()}async __loadEventFiles(){for await(const fsDirent of fs.readdirSync(this.eventDir,{withFileTypes:true})){const file=fsDirent.name;const fileType=path.extname(file);const fileName=path.basename(file,fileType);if(fsDirent.isDirectory()){await this.__loadEventCategoryFiles(file);continue}else if(![".js",".ts"].includes(fileType)){continue}let fileClass;fileClass=require(`${this.eventDir}/${file}`);if(_util.Util.isClass(fileClass)){fileClass=new fileClass(this.client);if(!(fileClass instanceof _Event.Event))return console.log(new _Color.Color(`&d[GEvents] &cEvent ${fileName} doesnt belong in Events.`).getText())}fileClass._path=`${this.eventDir}/${fileName}${fileType}`;this.client.gevents.set(fileName,fileClass);this.client.emit(_Constants.Events.LOG,new _Color.Color(`&d[GEvents] &aLoaded (File): &e➜   &3${fileName}`,{json:false}).getText())}await this.__loadEvents()}async __loadEventCategoryFiles(categoryFolder){for await(const fsDirent of fs.readdirSync(`${this.eventDir}/${categoryFolder}`,{withFileTypes:true})){const file=fsDirent.name;const fileType=path.extname(file);const fileName=path.basename(file,fileType);if(fsDirent.isDirectory()){await this.__loadEventCategoryFiles(`${categoryFolder}/${file}`);continue}else if(![".js",".ts"].includes(fileType)){continue}let fileClass;fileClass=require(`${this.eventDir}/${categoryFolder}/${file}`);if(_util.Util.isClass(fileClass)){fileClass=new fileClass(this.client);if(!(fileClass instanceof _Event.Event))return console.log(new _Color.Color(`&d[GEvents] &cEvent ${fileName} doesnt belong in Events.`).getText())}fileClass._path=`${this.eventDir}/${categoryFolder}/${fileName}.${fileType}`;this.client.gevents.set(fileName,fileClass);this.client.emit(_Constants.Events.LOG,new _Color.Color(`&d[GEvents] &aLoaded (File): &e➜   &3${fileName}`,{json:false}).getText())}}__loadEvents(){this.client.gevents.forEach(event=>{if(event.name==="ready")return event.run(this.client);if(event.ws){if(event.once)this.client.ws.once(event.name,(...args)=>event.run(this.client,...args));else this.client.ws.on(event.name,(...args)=>event.run(this.client,...args))}else if(event.once){this.client.once(event.name,(...args)=>event.run(this.client,...args))}else{this.client.on(event.name,(...args)=>event.run(this.client,...args))}})}}exports.GEvents=GEvents;